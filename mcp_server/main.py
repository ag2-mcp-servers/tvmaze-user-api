# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:48:29+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic

from models import (
    AuthPollPostRequest,
    AuthPollPostResponse,
    AuthStartPostRequest,
    AuthStartPostResponse,
    AuthValidateGetResponse,
    BulkResponse,
    Embed,
    Embed2,
    Embed4,
    Embed6,
    Embed8,
    Embed10,
    EpisodeVote,
    MarkedEpisode,
    NetworkFollow,
    PersonFollow,
    ScrobbleEpisodesPostRequest,
    ScrobbleShowsPostRequest,
    ScrobbleShowsShowIdGetResponse,
    ShowFollow,
    ShowVote,
    Tag,
    TagInstance,
    UserEpisodesGetResponse,
    UserFollowsNetworksGetResponse,
    UserFollowsPeopleGetResponse,
    UserFollowsShowsGetResponse,
    UserFollowsWebchannelsGetResponse,
    UserTagsGetResponse,
    UserTagsTagIdShowsGetResponse,
    UserVotesEpisodesGetResponse,
    UserVotesShowsGetResponse,
    WebchannelFollow,
)

app = MCPProxy(
    contact={'url': 'http://www.tvmaze.com'},
    description='Access to the user API is only possible for users with a [premium](http://www.tvmaze.com/premium) account. A user can only access their own user data.\n\nAuthentication uses HTTP Basic. Use the TVmaze username as authentication username, and the TVmaze API key as authentication password. Your API key can be found on your [dashboard](http://www.tvmaze.com/dashboard). To try out these API calls from this page, click the "Authorize" button on top and input your credentials.\n',
    title='TVmaze user API',
    version='1.0',
    servers=[{'url': 'https://api.tvmaze.com/v1'}, {'url': 'http://api.tvmaze.com/v1'}],
)


@app.post(
    '/auth/poll',
    description=""" Using the token acquired in the `start` endpoint, you can start polling this endpoint once every 10 seconds.

When the user has confirmed the authentication request on their end, this endpoint will return the user's API key that you can use in subsequent authenticated endpoints. Note that it'll do so only once, subsequent requests after the initial 200 response will return a 404.

For as long as the user did not yet confirm their authentication request, this endpoint will return a 403.
 """,
    tags=['authentication_requests'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_auth_poll(body: AuthPollPostRequest):
    """
    Poll whether an authentication request was confirmed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/start',
    description=""" If you want to access the TVmaze API on behalf of a user without querying them for their password, use this endpoint.

To get started, send a POST request containing the user's email address. The response will contain a `token`, which you can use as input to the `poll` endpoint. The user will receive an email prompting them to confirm the authentication request.

Alternatively, if you expect the user to be logged in to TVmaze on the device they are currently interacting with, you can set `email_confirmation` to false and redirect them to the `confirm_url` URL. If they are logged in to TVmaze, they will be able to confirm the authentication request instantly.
 """,
    tags=['authentication_requests'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_auth_start(body: AuthStartPostRequest):
    """
    Start an authentication request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/auth/validate',
    description=""" If the credentials supplied as HTTP basic are valid, the user's level of premium - if any - is returned. """,
    tags=['authentication_requests'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_auth_validate():
    """
    Validate your authentication credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scrobble/episodes',
    description=""" This endpoint can be used by all users, even without premium """,
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_scrobble_episodes(body: ScrobbleEpisodesPostRequest = None):
    """
    Mark episodes as acquired or watched based on their IDs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/scrobble/episodes/{episode_id}',
    description=""" This endpoint can be used by all users, even without premium """,
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_scrobble_episodes__episode_id(episode_id: int, body: MarkedEpisode = None):
    """
    Mark an episode as acquired or watched based on its ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/scrobble/shows',
    description=""" To specify a show, supply either `tvmaze_id`, `thetvdb_id` or `imdb_id`. To specify an episode, supply either both `season` and `episode`, or `airdate`.

This endpoint can be used by all users, even without premium.
 """,
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_scrobble_shows(
    tvmaze_id: Optional[int] = None,
    thetvdb_id: Optional[int] = None,
    imdb_id: Optional[int] = None,
    body: ScrobbleShowsPostRequest = None,
):
    """
    Mark episodes within a show as acquired or watched based on their attributes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/scrobble/shows/{show_id}',
    description=""" This endpoint can be used by all users, even without premium """,
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_scrobble_shows__show_id(show_id: int, embed: Optional[Embed] = None):
    """
    List watched and acquired episodes for a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/episodes',
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_episodes(show_id: Optional[int] = None):
    """
    List the marked episodes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/episodes/{episode_id}',
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_episodes__episode_id(episode_id: int):
    """
    Unmark an episode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/episodes/{episode_id}',
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_episodes__episode_id(episode_id: int):
    """
    Check if an episode is marked
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/episodes/{episode_id}',
    description=""" Set `marked_at` to `NULL` or leave it out to use the current time. """,
    tags=['episode_scrobbling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_episodes__episode_id(episode_id: int, body: MarkedEpisode = None):
    """
    Mark an episode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/networks',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_networks(embed: Optional[Embed2] = None):
    """
    List the followed networks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/follows/networks/{network_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_follows_networks__network_id(network_id: int):
    """
    Unfollow a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/networks/{network_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_networks__network_id(network_id: int):
    """
    Check if a network is followed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/follows/networks/{network_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_follows_networks__network_id(network_id: int):
    """
    Follow a network
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/people',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_people(embed: Optional[Embed4] = None):
    """
    List the followed people
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/follows/people/{person_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_follows_people__person_id(person_id: int):
    """
    Unfollow a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/people/{person_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_people__person_id(person_id: int):
    """
    Check if a person is followed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/follows/people/{person_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_follows_people__person_id(person_id: int):
    """
    Follow a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/shows',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_shows(embed: Optional[Embed6] = None):
    """
    List the followed shows
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/follows/shows/{show_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_follows_shows__show_id(show_id: int):
    """
    Unfollow a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/shows/{show_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_shows__show_id(show_id: int):
    """
    Check if a show is followed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/follows/shows/{show_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_follows_shows__show_id(show_id: int):
    """
    Follow a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/webchannels',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_webchannels(embed: Optional[Embed8] = None):
    """
    List the followed webchannels
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/follows/webchannels/{webchannel_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_follows_webchannels__webchannel_id(webchannel_id: int):
    """
    Unfollow a webchannel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/follows/webchannels/{webchannel_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_follows_webchannels__webchannel_id(webchannel_id: int):
    """
    Check if a webchannel is followed
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/follows/webchannels/{webchannel_id}',
    tags=['user_follow_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_follows_webchannels__webchannel_id(webchannel_id: int):
    """
    Follow a webchannel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/tags',
    tags=['user_defined_tags_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_tags():
    """
    List all tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/user/tags',
    tags=['user_defined_tags_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_user_tags(body: Tag = None):
    """
    Create a new tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/tags/{tag_id}',
    tags=['user_defined_tags_management', 'user_show_tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_tags__tag_id(tag_id: int):
    """
    Delete a specific tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/user/tags/{tag_id}',
    tags=['user_defined_tags_management', 'user_show_tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_user_tags__tag_id(tag_id: int, body: Tag = None):
    """
    Update a specific tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/tags/{tag_id}/shows',
    tags=['user_show_tag_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_tags__tag_id_shows(tag_id: int, embed: Optional[Embed10] = None):
    """
    List all shows under this tag
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/tags/{tag_id}/shows/{show_id}',
    tags=['user_show_tag_management', 'user_defined_tags_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_tags__tag_id_shows__show_id(tag_id: int, show_id: int = ...):
    """
    Untag a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/tags/{tag_id}/shows/{show_id}',
    tags=['user_show_tag_management', 'user_defined_tags_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_tags__tag_id_shows__show_id(tag_id: int, show_id: int = ...):
    """
    Tag a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/votes/episodes',
    tags=['user_vote_handling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_votes_episodes():
    """
    List the episodes voted for
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/votes/episodes/{episode_id}',
    tags=['user_vote_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_votes_episodes__episode_id(episode_id: int):
    """
    Remove an episode vote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/votes/episodes/{episode_id}',
    tags=['user_vote_handling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_votes_episodes__episode_id(episode_id: int):
    """
    Check if an episode is voted for
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/votes/episodes/{episode_id}',
    tags=['user_vote_handling', 'user_episode_tracking'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_votes_episodes__episode_id(episode_id: int, body: EpisodeVote = None):
    """
    Vote for an episode
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/votes/shows',
    tags=['user_vote_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_votes_shows(embed: Optional[Embed10] = None):
    """
    List the shows voted for
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/user/votes/shows/{show_id}',
    tags=['user_vote_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_votes_shows__show_id(show_id: int):
    """
    Remove a show vote
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/user/votes/shows/{show_id}',
    tags=['user_vote_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_votes_shows__show_id(show_id: int):
    """
    Check if a show is voted for
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/user/votes/shows/{show_id}',
    description=""" Set `voted_at` to `NULL` or leave it out to use the current time. """,
    tags=['user_vote_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def put_user_votes_shows__show_id(show_id: int, body: ShowVote = None):
    """
    Vote for a show
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
